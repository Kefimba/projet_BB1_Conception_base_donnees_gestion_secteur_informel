---
title: "PROJET 3 : Conception d'une base de donnees"
subtitle: "Plateforme de gestion, de suivi et d'analyse du secteur informel"
author: ""
date: ""
site: bookdown::bookdown_site
documentclass: book
header-includes:
  - \usepackage{underscore}
lang: fr
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center"
)
```

```{r helpers, include=FALSE}
# Helper to escape underscores in character columns (LaTeX-safe)
escape_underscore <- function(df) {
  df[] <- lapply(df, function(col) if (is.character(col)) gsub("_", "\\\\_", col) else col)
  df
}
```

#  {-}

<style>
/* 1. RESET & FOND GLOBAL */
.book .book-body, .book .book-body .page-wrapper .page-inner {
    background-color: #f8fafc !important; /* Gris très clair "Premium" */
}

/* On cache le titre automatique généré par Bookdown */
h1 { display: none; } 

/* 2. LOGOS */
.header-logos {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 20px auto 40px auto;
    max-width: 900px;
}

.logo-item img {
    height: 70px;
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.05));
    transition: transform 0.3s ease;
}

.logo-item img:hover { transform: translateY(-5px); }

/* 3. CARTE PRINCIPALE */
.main-cover-card {
    background: #ffffff;
    border-radius: 32px;
    padding: 60px 50px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.04), 0 1px 3px rgba(0,0,0,0.02);
    border: 1px solid rgba(226, 232, 240, 0.8);
    text-align: center;
    max-width: 900px;
    margin: 0 auto 50px auto;
    position: relative;
}

.badge-pill {
    display: inline-block;
    padding: 8px 10px;
    background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
    color: #4338ca;
    border-radius: 99px;
    font-size: 0.75em;
    font-weight: 800;
    letter-spacing: 1px;
    margin-bottom: 10px;
    border: 1px solid #c7d2fe;
}

.main-title {
    display: block !important;
    font-size: 3.2em !important;
    font-weight: 900 !important;
    color: #0f172a !important;
    letter-spacing: -1.5px !important;
    line-height: 1.1 !important;
    margin-bottom: 15px !important;
    border: none !important;
}

.sub-title {
    font-size: 1.2em;
    color: #64748b;
    font-weight: 400;
    margin-bottom: 40px;
}

/* 4. GRILLE DES INFOS */
.cover-grid {
    display: flex;
    gap: 24px;
    text-align: left;
}

.cover-box {
    flex: 1;
    background: #fdfdfd;
    padding: 30px;
    border-radius: 24px;
    border: 1px solid #f1f5f9;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.01);
}

.cover-kicker {
    font-size: 0.65em;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: #2D7FF9;
    font-weight: 800;
    margin-bottom: 15px;
}

.cover-names {
    font-size: 0.95em;
    font-weight: 600;
    color: #1e293b;
    line-height: 1.7;
}

.supervisor-name {
    font-size: 1.1em;
    font-weight: 800;
    color: #0f172a;
}

.cover-note {
    font-size: 0.8em;
    color: #94a3b8;
    margin-top: 10px;
    display: block;
}

.context-tag {
    display: inline-block;
    margin-top: 20px;
    padding: 10px 15px;
    background: #f8fafc;
    border-radius: 12px;
    border-left: 4px solid #2D7FF9;
    font-size: 0.8em;
    color: #475569;
}
</style>

<div class="header-logos">
<div class="logo-item">
<img src="images/LOGO_ANSD.jpg">
<div style="font-size:0.75em; font-weight:600; color:#4b5563;">Agence Nationale de la Statistique et de la Démographie (ANSD)</div>
</div>
<div class="logo-item">
<img src="images/LOGO_ENSAE.jpg">
<div style="font-size:0.75em; font-weight:600; color:#4b5563;">École Nationale de la Statistique et de l’Analyse Économique (ENSAE)</div>
</div>
</div>

<div class="main-cover-card">
<div class="badge-pill">PRÉSENTATION DU PROJET – ANNÉE ACADÉMIQUE 2025-2026</div>

<h1 class="main-title">Plateforme de gestion, de suivi et d'analyse du secteur informel</h1>
<div style="color:#6b7280; font-size:1.1em; margin-bottom:20px;">BASE DE DONNEES 1 — Rapport du projet de creation d'une base de donnees pour le secteur informel au Sénégal</div>

<div style="height:3px; width:60px; background:#2D7FF9; margin:0 auto;"></div>

<div class="cover-grid">
<div class="cover-box">
<div class="cover-kicker">Rédigé par</div>
<div class="cover-names">
Paul BALAFAI</br>
DIALLO Cheikh Oumar<br/>
Mamady I BERETE
</div>
<div class="cover-note">Élèves ingénieurs statisticiens économistes (ISE 2)</div>
</div>

<div class="cover-box">
<div class="cover-kicker">Sous la supervision de</div>
<div class="cover-supervisor">M. Demba DIACK</div>
<div class="cover-pill-small">Projet réalisé dans le cadre du cours de base de données 1</div>
</div>
</div>

<div style="margin-top:30px; font-size:0.75em; color:#9ca3af;">
Document généré via R Bookdown .
</div>
</div>

<div style="text-align:center; margin-top:20px;">
  <span style="font-size:1.1em; font-weight:700; color:#1e293b;">ENSAE Dakar - ISE 2</span><br/>
  <span style="font-size:1em; color:#64748b;">`r format(Sys.Date(), '%d %B %Y')`</span>
</div>


# Introduction {-}

<!-- Load custom TOC highlight script -->
<script src="js/toc-highlight.js"></script>

Ce rapport présente la conception complète d'une base de données dédiée à la **gestion, au suivi et à l'analyse du secteur informel au Sénégal**.
Il s'inscrit dans une logique de production d'indicateurs fiables, territorialisés et exploitables pour l'aide à la décision publique.

Le système de gestion de base de données relationnelle (SGBDR) retenu est **PostgreSQL**, choisi pour sa robustesse, sa conformité aux standards SQL et ses fonctionnalités avancées.

# Analyse fonctionnelle {#analyse}

## Contexte et problématique

Au Sénégal, le secteur informel occupe une place centrale dans l'emploi et la production, mais il demeure insuffisamment documenté. Les données existantes sont souvent fragmentées, non standardisées et parfois obsolètes, ce qui limite :

- la production d'indicateurs fiables ;
- la territorialisation des diagnostics ;
- le ciblage efficace des politiques publiques.

## Objectif général

L'objectif est de concevoir une base de données capable de recenser les unités et travailleurs du secteur informel, de caractériser les activités et leur organisation spatiale, et d'assurer le suivi de l'emploi, des revenus et des charges dans une logique d'historisation. Elle doit également permettre de documenter les vulnérabilités et besoins, de relier les unités aux programmes d'appui et aux résultats obtenus, ainsi que de gérer les documents associés (fiches, photos, autorisations, rapports).

## Acteurs du système {#acteurs}

Le tableau \@ref(tab:acteurs) présente les différents acteurs du système et leurs responsabilités.

```{r acteurs}
acteurs <- data.frame(
  Acteur = c("Administrateur national", "Agent de recensement", "Superviseur régional", 
             "Analyste statistique", "Décideur public"),
  Responsabilités = c(
    "Paramétrage des référentiels, gestion des comptes utilisateurs",
    "Collecte et mise à jour des données terrain",
    "Contrôle qualité et validation des données",
    "Requêtes, indicateurs et exports de données",
    "Consultation des synthèses et indicateurs"
  )
)
knitr::kable(acteurs, caption = "Acteurs du système et leurs responsabilités")
```

```{r acteurs-table-escape, include=FALSE}
acteurs <- escape_underscore(acteurs)
knitr::kable(acteurs, caption = "Acteurs du système et leurs responsabilités", escape = TRUE)
```

## Processus métier
Les processus métier principaux de la plateforme sont structurés pour garantir une gestion exhaustive et dynamique du secteur informel :

1. **Paramétrage des référentiels**  
  L’administrateur configure les bases territoriales (régions, départements, communes, sites) et les référentiels métiers (activités économiques, équipements, profils d’accès). Cette étape assure la cohérence et la standardisation des données collectées.

2. **Recensement et caractérisation des unités informelles**  
  Les agents de terrain identifient chaque unité informelle, renseignent ses caractéristiques (type d’activité, statut juridique, localisation précise) et l’associent aux référentiels. Ce processus permet de dresser une cartographie fine et actualisée du tissu informel.

3. **Enregistrement des travailleurs**  
  Pour chaque unité, les profils socio-démographiques des travailleurs sont saisis : âge, sexe, niveau d’instruction, rôle dans l’unité, ancienneté, couverture sociale. Ce volet éclaire la structure humaine du secteur et ses dynamiques internes.

4. **Saisie et historisation des observations économiques**  
  Les agents collectent périodiquement des données économiques (revenus, charges, effectifs, variations saisonnières), permettant un suivi longitudinal et l’analyse des évolutions dans le temps.

5. **Déclaration des vulnérabilités et besoins**  
  Les difficultés rencontrées, les risques identifiés et les besoins exprimés sont documentés pour chaque unité. Cette démarche favorise la détection précoce des situations critiques et l’orientation des politiques d’appui.

6. **Gestion des programmes d’appui et des participations**  
  Les superviseurs planifient des sessions de formation ou d’accompagnement, inscrivent les unités participantes et suivent les résultats obtenus (financements, certifications, impacts). Ce processus relie les interventions publiques aux bénéficiaires réels.

7. **Production d’indicateurs, analyses et tableaux de bord**  
  Les analystes exploitent la base pour générer des indicateurs fiables, réaliser des requêtes avancées et produire des tableaux de bord interactifs. Ces outils facilitent la prise de décision et le pilotage stratégique du secteur informel.

Chaque processus est conçu pour être traçable, évolutif et interconnecté, garantissant ainsi une gestion proactive et une valorisation optimale des données collectées.


# Diagramme de contexte {#contexte}

Le diagramme de contexte présente le système étudié comme une boîte noire et met en évidence 
les interactions entre la plateforme de gestion du secteur informel et les acteurs externes.
La figure \@ref(fig:diagramme-contexte) illustre ces flux d'information.

```{r diagramme-contexte, fig.cap="Diagramme de contexte de la plateforme BD Secteur Informel", out.width="100%", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}
library(DiagrammeR)

grViz("
digraph contexte {
  # Configuration generale du graphe
  graph [
    layout = dot,
    rankdir = LR,
    bgcolor = '#ffffff',
    fontname = 'Helvetica',
    splines = ortho,
    nodesep = 0.8,
    ranksep = 1.5
  ]
  
  # Style par defaut des noeuds
  node [
    fontname = 'Helvetica',
    fontsize = 11,
    style = 'filled,rounded',
    penwidth = 2
  ]
  
  # Style par defaut des aretes
  edge [
    fontname = 'Helvetica',
    fontsize = 10,
    penwidth = 1.5,
    arrowsize = 0.8
  ]
  
  # ========== ACTEURS EXTERNES (gauche) ==========
  subgraph cluster_acteurs {
    label = 'ACTEURS'
    labeljust = 'l'
    fontname = 'Helvetica Bold'
    fontsize = 12
    fontcolor = '#1e3a5f'
    style = 'dashed'
    color = '#94a3b8'
    bgcolor = '#f8fafc'
    
    Admin [
      label = '👤 Administrateur\\nnational'
      shape = box
      fillcolor = '#dbeafe'
      color = '#2563eb'
    ]
    
    Agent [
      label = '👤 Agent de\\nrecensement'
      shape = box
      fillcolor = '#dbeafe'
      color = '#2563eb'
    ]
    
    Superviseur [
      label = '👤 Superviseur\\nrégional'
      shape = box
      fillcolor = '#dbeafe'
      color = '#2563eb'
    ]
    
    Analyste [
      label = '👤 Analyste\\nstatistique'
      shape = box
      fillcolor = '#dbeafe'
      color = '#2563eb'
    ]
    
    Decideur [
      label = '👤 Décideur\\npublic'
      shape = box
      fillcolor = '#dbeafe'
      color = '#2563eb'
    ]
  }
  
  # ========== SYSTEME CENTRAL ==========
  Systeme [
    label = '\\n🗄️ PLATEFORME BD\\nSECTEUR INFORMEL\\n\\nPostgreSQL / MySQL\\n'
    shape = box
    style = 'filled,bold,rounded'
    fillcolor = '#c7d2fe'
    color = '#4338ca'
    fontsize = 14
    fontname = 'Helvetica Bold'
    penwidth = 3
    width = 2.8
    height = 1.8
  ]
  
  # ========== ENTREES (gauche du systeme) ==========
  subgraph cluster_entrees {
    label = 'ENTRÉES'
    labeljust = 'l'
    fontname = 'Helvetica Bold'
    fontsize = 12
    fontcolor = '#166534'
    style = 'dashed'
    color = '#86efac'
    bgcolor = '#f0fdf4'
    
    Terrain [
      label = '📋 Données terrain\\n(recensement, enquêtes)'
      shape = note
      fillcolor = '#bbf7d0'
      color = '#16a34a'
    ]
    
    Referentiels [
      label = '📍 Référentiels\\nterritoriaux'
      shape = note
      fillcolor = '#bbf7d0'
      color = '#16a34a'
    ]
    
    Programmes [
      label = '🎯 Programmes\\nd\\'appui publics'
      shape = note
      fillcolor = '#bbf7d0'
      color = '#16a34a'
    ]
    
    Documents [
      label = '📄 Documents\\njustificatifs'
      shape = note
      fillcolor = '#bbf7d0'
      color = '#16a34a'
    ]
  }
  
  # ========== SORTIES (droite du systeme) ==========
  subgraph cluster_sorties {
    label = 'SORTIES'
    labeljust = 'r'
    fontname = 'Helvetica Bold'
    fontsize = 12
    fontcolor = '#9a3412'
    style = 'dashed'
    color = '#fdba74'
    bgcolor = '#fff7ed'
    
    Indicateurs [
      label = '📊 Indicateurs\\néconomiques et sociaux'
      shape = note
      fillcolor = '#fed7aa'
      color = '#ea580c'
    ]
    
    Listes [
      label = '📋 Listes\\nopérationnelles'
      shape = note
      fillcolor = '#fed7aa'
      color = '#ea580c'
    ]
    
    Rapports [
      label = '📈 Rapports et\\nextractions'
      shape = note
      fillcolor = '#fed7aa'
      color = '#ea580c'
    ]
    
    Tableaux [
      label = '📉 Tableaux de bord\\nsuivi programmes'
      shape = note
      fillcolor = '#fed7aa'
      color = '#ea580c'
    ]
  }
  
  # ========== FLUX ACTEURS -> SYSTEME ==========
  Admin -> Systeme [label = 'Paramétrage', color = '#2563eb', fontcolor = '#1e40af']
  Agent -> Systeme [label = 'Saisie données', color = '#2563eb', fontcolor = '#1e40af']
  Superviseur -> Systeme [label = 'Validation', color = '#2563eb', fontcolor = '#1e40af']
  Analyste -> Systeme [label = 'Requêtes', color = '#2563eb', fontcolor = '#1e40af']
  Decideur -> Systeme [label = 'Consultation', color = '#2563eb', fontcolor = '#1e40af']
  
  # ========== FLUX ENTREES -> SYSTEME ==========
  Terrain -> Systeme [color = '#16a34a', style = 'dashed']
  Referentiels -> Systeme [color = '#16a34a', style = 'dashed']
  Programmes -> Systeme [color = '#16a34a', style = 'dashed']
  Documents -> Systeme [color = '#16a34a', style = 'dashed']
  
  # ========== FLUX SYSTEME -> SORTIES ==========
  Systeme -> Indicateurs [color = '#ea580c', style = 'dashed']
  Systeme -> Listes [color = '#ea580c', style = 'dashed']
  Systeme -> Rapports [color = '#ea580c', style = 'dashed']
  Systeme -> Tableaux [color = '#ea580c', style = 'dashed']
  
  # ========== ALIGNEMENT ==========
  {rank = same; Admin; Agent; Superviseur; Analyste; Decideur}
  {rank = same; Terrain; Referentiels; Programmes; Documents}
  {rank = same; Indicateurs; Listes; Rapports; Tableaux}
}
")
```

**Légende du diagramme :**

- **Boîtes bleues** : Acteurs du système (utilisateurs humains)
- **Notes vertes** : Données et documents en entrée du système
- **Notes orange** : Productions et sorties du système
- **Rectangle central violet** : Système d'information (base de données)

## Entrees

- Donnees terrain (recensement, enquetes)
- Referentiels territoriaux et sectoriels
- Programmes publics d'appui
- Documents justificatifs

## Sorties

- Indicateurs economiques et sociaux
- Listes operationnelles (unites, travailleurs, beneficiaires)
- Rapports et extractions statistiques
- Tableaux de suivi des programmes

# Modele Conceptuel de Donnees {#mcd}

Le Modele Conceptuel de Donnees (Merise) decrit les principales entites, associations et cardinalites necessaires a la gestion du secteur informel.

La figure \@ref(fig:mcd-diagramme) presente le diagramme MCD complet de la base de donnees.

```{r mcd-diagramme, fig.cap="Diagramme du Modele Conceptuel de Donnees (MCD)", out.width="100%", fig.align="center"}
knitr::include_graphics("images/MCD_looping.png")
```

## Entites principales

Le MCD comprend les entites suivantes organisees en domaines fonctionnels :

### Decoupage territorial

- **REGION** : decoupage administratif de niveau 1
- **DEPARTEMENT** : decoupage administratif de niveau 2
- **COMMUNE** : decoupage administratif de niveau 3
- **SITE** : lieu physique d'exercice des activites (marche, zone artisanale, etc.)

### Unites et activites

- **ACTIVITE_ECO** : classification des activites economiques (secteur, sous-secteur, type de production)
- **UNITE_INFORMELLE** : entite centrale representant une unite de production informelle
- **TRAVAILLEUR** : personnes travaillant dans les unites informelles
- **SITUATION_ECO** : observations economiques datees (revenus, charges, effectifs)

### Contraintes et vulnérabilités

- **DIFFICULTE** : types de difficultes rencontrees
- **RISQUE** : types de risques encourus
- **BESOIN** : types de besoins exprimes

### Appuis publics

- **PROGRAMME** : programmes publics d'accompagnement
- **SESSION_PROG** : sessions de formation ou d'appui

### Gestion documentaire

- **DOCUMENT** : pieces justificatives et rapports

## Associations et cardinalites {#associations}

Le tableau \@ref(tab:associations) presente les associations entre entites et leurs cardinalites.

```{r associations}
assoc <- data.frame(
  Association = c("CONTENIR", "COMPORTER", "POSSEDER", "LIER", "EXERCER", "APPARTENIR",
                  "AVOIR_OBSERVATIONS", "UTILISER", "DECLARER_DIFFICULTE", "DECLARER_RISQUE",
                  "EXPRIMER_BESOIN", "AVOIR_SESSIONS", "PARTICIPER", "DEPOSER", "CONCERNER", "AVOIR_ROLE"),
  Entite1 = c("REGION", "DEPARTEMENT", "COMMUNE", "SITE", "ACTIVITE_ECO", "UNITE_INFORMELLE",
                 "UNITE_INFORMELLE", "ACTIVITE_ECO", "UNITE_INFORMELLE", "UNITE_INFORMELLE",
                 "UNITE_INFORMELLE", "PROGRAMME", "UNITE_INFORMELLE", "UTILISATEUR", "UNITE_INFORMELLE", "ROLE"),
  Card1 = c("(1,n)", "(1,n)", "(0,n)", "(1,n)", "(1,n)", "(1,n)",
                "(1,n)", "(0,n)", "(0,n)", "(0,n)", "(0,n)", "(1,n)", "(0,n)", "(0,n)", "(0,n)", "(1,n)"),
  Entite2 = c("DEPARTEMENT", "COMMUNE", "SITE", "UNITE_INFORMELLE", "UNITE_INFORMELLE", "TRAVAILLEUR",
                 "SITUATION_ECO", "EQUIPEMENT", "DIFFICULTE", "RISQUE",
                 "BESOIN", "SESSION_PROG", "SESSION_PROG", "DOCUMENT", "DOCUMENT", "UTILISATEUR"),
  Card2 = c("(1,1)", "(1,1)", "(1,1)", "(1,1)", "(1,1)", "(1,1)",
                "(1,1)", "(0,n)", "(0,n)", "(0,n)", "(0,n)", "(1,1)", "(0,n)", "(1,1)", "(1,1)", "(1,1)")
)
assoc <- escape_underscore(assoc)
knitr::kable(assoc, caption = "Associations et cardinalites du MCD",
             col.names = c("Association", "Entite 1", "Card. 1", "Entite 2", "Card. 2"), escape = TRUE)
```

# Modele Logique de Donnees {#mld}

La traduction du MCD vers le modele relationnel suit les regles classiques de transformation Merise. Le MLD represente la structure logique des tables, leurs attributs et les liens entre elles.

La figure \@ref(fig:mld-diagramme) presente le diagramme MLD complet issu de la transformation du MCD.

```{r mld-diagramme, fig.cap="Diagramme du Modele Logique de Donnees (MLD)", out.width="100%", fig.align="center"}
knitr::include_graphics("images/MLD.png")
```

**Legende du MLD :**

- **#attribut** : cle primaire de la table
- **@attribut** : cle etrangere (reference vers une autre table)
- Les fleches representent les relations de dependance entre tables

## Tables issues des entites

### Referentiels utilisateurs

- **ROLE** (#id_role, libelle_role)
- **UTILISATEUR** (#id_user, nom, prenom, email, telephone, date_creation, actif, @id_role)

### Decoupage territorial

- **REGION** (#id_region, nom_region)
- **DEPARTEMENT** (#id_dept, nom_dept, @id_region)
- **COMMUNE** (#id_commune, nom_commune, type_commune, @id_dept)
- **SITE** (#id_site, nom_site, type_site, description, @id_commune)

### Unites et activites

- **ACTIVITE_ECO** (#id_activite, secteur, sous_secteur, type_production, saisonnalite, description)
- **UNITE_INFORMELLE** (#id_unite, code_unite, nom_activite, type_activite, statut_juridique, date_creation, niveau_formalisation, ca_estime, @id_site, @id_activite)
- **TRAVAILLEUR** (#id_trav, identifiant_ext, sexe, age, niveau_instruction, role_unite, anciennete_mois, couverture_sociale, @id_unite)
- **SITUATION_ECO** (#id_sit, nb_travailleurs_decl, revenu_mensuel_estime, charges_principales, variation_saisonniere, date_obs, @id_unite)

### Vulnerabilites (referentiels)

- **DIFFICULTE** (#id_diff, libelle_diff)
- **RISQUE** (#id_risque, libelle_risque)
- **BESOIN** (#id_besoin, libelle_besoin)
- **EQUIPEMENT** (#id_equipement, libelle_equipement)

### Programmes

- **PROGRAMME** (#id_prog, nom_prog, type_prog, organisme, description, date_debut, date_fin)
- **SESSION_PROG** (#id_session, libelle_session, date_debut, date_fin, lieu, @id_prog)

### Documents

- **DOCUMENT** (#id_doc, type_doc, date_doc, chemin_fichier, commentaire, @id_user, @id_unite)

## Tables d'association

- **UTILISER** (@id_activite, @id_equipement, remarque)
- **DECLARER_DIFFICULTE** (@id_unite, @id_diff, date_decl, niveau_severite)
- **DECLARER_RISQUE** (@id_unite, @id_risque, date_decl, probabilite_percue)
- **EXPRIMER_BESOIN** (@id_unite, @id_besoin, date_decl, priorite)
- **PARTICIPER** (@id_unite, @id_session, date_inscription, statut, resultat_obtenu, montant_financement)

# Modele Physique de Donnees {#mpd}

Le MPD est implemente en **MySQL** et respecte les bonnes pratiques de conception. Il traduit le MLD en instructions SQL executables pour creer la structure de la base de donnees.

## Conventions de nommage

- Noms de tables en minuscules avec underscores (snake_case)
- Cles primaires nommees `id_<entite>` avec AUTO_INCREMENT
- Cles etrangeres portant le meme nom que la cle primaire referencee
- Contraintes UNIQUE pour garantir l'unicite des valeurs metier
- Valeurs par defaut definies avec DEFAULT

## Types de donnees utilises {#types}

Le tableau \@ref(tab:types) presente les types de donnees MySQL utilises dans ce projet.

```{r types}
types <- data.frame(
  Type = c("INT AUTO_INCREMENT", "VARCHAR(n)", "TEXT", "INT", "DECIMAL(18,2)", 
           "DATE", "DATETIME", "BOOLEAN", "CHAR(1)"),
  Utilisation = c("Identifiants auto-incrementes (cles primaires)", "Chaines de caracteres de taille limitee",
                  "Textes longs (descriptions, commentaires)", "Entiers (age, effectifs, durees)",
                  "Montants monetaires avec 2 decimales", "Dates sans heure (AAAA-MM-JJ)", "Dates avec heure (creation compte)",
                  "Valeurs booleennes (actif, couverture sociale)", "Codes courts (sexe M/F)")
)
types <- escape_underscore(types)
knitr::kable(types, caption = "Types de donnees MySQL utilises",
             col.names = c("Type MySQL", "Utilisation"), escape = TRUE)
```

## Script DDL complet

Le script ci-dessous presente l'ensemble des instructions CREATE TABLE pour implementer la base de donnees. Les tables sont creees dans un ordre respectant les dependances referentielles.

### Tables de reference (sans dependances)

Ces tables contiennent les donnees de reference du systeme et n'ont aucune dependance externe.

```sql
-- Table ROLE : Definit les profils d'acces au systeme
-- Permet de gerer les droits des utilisateurs (admin, agent, superviseur...)
CREATE TABLE role(
   id_role INT AUTO_INCREMENT,
   libelle_role VARCHAR(50) NOT NULL,
   PRIMARY KEY(id_role),
   UNIQUE(libelle_role)  -- Un role ne peut exister qu'une seule fois
);

-- Table REGION : Premier niveau du decoupage territorial senegalais
CREATE TABLE region(
   id_region INT AUTO_INCREMENT,
   nom_region VARCHAR(120) NOT NULL,
   PRIMARY KEY(id_region),
   UNIQUE(nom_region)  -- Chaque region a un nom unique
);

-- Table ACTIVITE_ECO : Referentiel des activites economiques
-- Classifie les unites informelles par secteur et type de production
CREATE TABLE activite_eco(
   id_activite INT AUTO_INCREMENT,
   secteur VARCHAR(30) NOT NULL,           -- Commerce, Artisanat, Services...
   sous_secteur VARCHAR(80),               -- Sous-categorie optionnelle
   type_production VARCHAR(80),            -- Nature des biens/services produits
   equipements_utilises TEXT,              -- Description des equipements
   saisonnalite VARCHAR(60),               -- Activite saisonniere ou permanente
   PRIMARY KEY(id_activite)
);

-- Tables de vulnerabilites : Referentiels des difficultes, risques et besoins
CREATE TABLE difficulte(
   id_diff INT AUTO_INCREMENT,
   libelle_diff VARCHAR(120) NOT NULL,
   PRIMARY KEY(id_diff),
   UNIQUE(libelle_diff)
);

CREATE TABLE risque(
   id_risque INT AUTO_INCREMENT,
   libelle_risque VARCHAR(120) NOT NULL,
   PRIMARY KEY(id_risque),
   UNIQUE(libelle_risque)
);

CREATE TABLE besoin(
   id_besoin INT AUTO_INCREMENT,
   libelle_besoin VARCHAR(120) NOT NULL,
   PRIMARY KEY(id_besoin),
   UNIQUE(libelle_besoin)
);

-- Table PROGRAMME : Programmes publics d'appui au secteur informel
CREATE TABLE programme(
   id_prog INT AUTO_INCREMENT,
   nom_prog VARCHAR(160) NOT NULL,
   type_prog VARCHAR(60) NOT NULL,         -- Formation, Financement, Accompagnement...
   organisme VARCHAR(120),                 -- Organisme porteur du programme
   description TEXT,
   date_debut DATE,
   date_fin DATE,
   montant_financement DECIMAL(18,2),      -- Budget total alloue
   PRIMARY KEY(id_prog)
);
```

### Tables avec dependances simples (niveau 1)

Ces tables dependent d'une seule table parente.

```sql
-- Table UTILISATEUR : Agents et administrateurs du systeme
-- Liee a ROLE pour definir les droits d'acces
CREATE TABLE utilisateur(
   id_user INT AUTO_INCREMENT,
   nom VARCHAR(80) NOT NULL,
   prenom VARCHAR(80) NOT NULL,
   email VARCHAR(120) NOT NULL,
   role_utilisateur VARCHAR(120) NOT NULL,  -- Description textuelle du role
   telephone VARCHAR(13),
   date_creation DATETIME NOT NULL DEFAULT NOW(),  -- Date auto a l'insertion
   actif BOOLEAN NOT NULL DEFAULT TRUE,            -- Compte actif par defaut
   id_role INT NOT NULL,
   PRIMARY KEY(id_user),
   UNIQUE(email),                           -- Email unique pour chaque utilisateur
   FOREIGN KEY(id_role) REFERENCES role(id_role)
);

-- Table DEPARTEMENT : Deuxieme niveau territorial, depend de REGION
CREATE TABLE departement(
   id_dept INT AUTO_INCREMENT,
   nom_dept VARCHAR(120) NOT NULL,
   id_region INT NOT NULL,
   PRIMARY KEY(id_dept),
   UNIQUE(nom_dept, id_region),             -- Nom unique par region
   FOREIGN KEY(id_region) REFERENCES region(id_region)
);

-- Table SESSION_PROG : Sessions de formation/accompagnement d'un programme
CREATE TABLE session_prog(
   id_session INT AUTO_INCREMENT,
   libelle_session VARCHAR(160) NOT NULL,
   date_debut DATE,
   date_fin DATE,
   lieu VARCHAR(160),
   id_prog INT NOT NULL,
   PRIMARY KEY(id_session),
   FOREIGN KEY(id_prog) REFERENCES programme(id_prog)
);
```

### Tables avec dependances en cascade (niveau 2+)

Ces tables sont situees plus bas dans la hierarchie des dependances.

```sql
-- Table COMMUNE : Troisieme niveau territorial, depend de DEPARTEMENT
CREATE TABLE commune(
   id_commune INT AUTO_INCREMENT,
   nom_commune VARCHAR(120) NOT NULL,
   type_commune VARCHAR(40),                -- Urbaine, rurale, semi-urbaine
   id_dept INT NOT NULL,
   PRIMARY KEY(id_commune),
   UNIQUE(nom_commune, id_dept),            -- Nom unique par departement
   FOREIGN KEY(id_dept) REFERENCES departement(id_dept)
);

-- Table SITE : Lieux d'exercice des activites informelles
-- Marches, zones artisanales, espaces commerciaux...
CREATE TABLE site(
   id_site INT AUTO_INCREMENT,
   nom_site VARCHAR(140) NOT NULL,
   type_site VARCHAR(60) NOT NULL,          -- Marche, atelier, espace commercial...
   description TEXT,
   id_commune INT NOT NULL,
   PRIMARY KEY(id_site),
   UNIQUE(nom_site, id_commune),            -- Nom unique par commune
   FOREIGN KEY(id_commune) REFERENCES commune(id_commune)
);
```

### Tables metier principales

Ces tables constituent le coeur fonctionnel de la base de donnees.

```sql
-- Table UNITE_INFORMELLE : Entite centrale du systeme
-- Represente une unite de production du secteur informel
CREATE TABLE unite_informelle(
   id_unite INT AUTO_INCREMENT,
   code_unite VARCHAR(40) NOT NULL,         -- Code unique d'identification
   nom_activite VARCHAR(160) NOT NULL,      -- Denomination de l'activite principale
   type_activite VARCHAR(80),               -- Production, commerce, services
   statut_juridique VARCHAR(60),            -- Formel, semi-formel, informel
   date_creation DATE,                      -- Date de creation de l'unite
   niveau_formalisation VARCHAR(40) NOT NULL, -- Degre de formalisation
   ca_estime DECIMAL(18,2),                 -- Chiffre d'affaires estime annuel
   id_activite INT NOT NULL,
   id_site INT NOT NULL,
   PRIMARY KEY(id_unite),
   UNIQUE(id_site),                         -- Une unite par site
   UNIQUE(code_unite),                      -- Code unique
   FOREIGN KEY(id_activite) REFERENCES activite_eco(id_activite),
   FOREIGN KEY(id_site) REFERENCES site(id_site)
);

-- Table TRAVAILLEUR : Personnes travaillant dans les unites informelles
CREATE TABLE travailleur(
   id_trav INT AUTO_INCREMENT,
   identifiant_ext VARCHAR(60),             -- Identifiant externe (CNI, etc.)
   sexe CHAR(1) NOT NULL,                   -- M ou F
   age INT,
   niveau_instruction VARCHAR(60),          -- Primaire, secondaire, superieur...
   role_unite VARCHAR(40) NOT NULL,         -- Patron, employe, apprenti...
   anciennete_mois INT,                     -- Anciennete en mois
   couverture_sociale BOOLEAN NOT NULL DEFAULT FALSE, -- Protection sociale
   id_unite INT NOT NULL,
   PRIMARY KEY(id_trav),
   FOREIGN KEY(id_unite) REFERENCES unite_informelle(id_unite)
);

-- Table SITUATION_ECO : Observations economiques periodiques
-- Permet l'historisation des donnees economiques des unites
CREATE TABLE situation_eco(
   id_sit INT AUTO_INCREMENT,
   nb_travailleurs INT,                     -- Effectif declare
   revenu_mensuel_estime DECIMAL(18,2),     -- Revenu mensuel
   charges_principales DECIMAL(18,2),       -- Charges mensuelles
   variation_saisonniere VARCHAR(60),       -- Impact de la saison
   date_obs DATE NOT NULL,                  -- Date de l'observation
   id_unite INT NOT NULL,
   PRIMARY KEY(id_sit),
   UNIQUE(id_unite, date_obs),              -- Une observation par date et unite
   FOREIGN KEY(id_unite) REFERENCES unite_informelle(id_unite)
);

-- Table DOCUMENT : Pieces justificatives et documents associes
CREATE TABLE document(
   id_doc INT AUTO_INCREMENT,
   type_doc VARCHAR(60) NOT NULL,           -- Type de document
   date_doc DATE NOT NULL,
   id_unite INT NOT NULL,
   id_user INT NOT NULL,                    -- Utilisateur ayant depose le document
   PRIMARY KEY(id_doc),
   FOREIGN KEY(id_unite) REFERENCES unite_informelle(id_unite),
   FOREIGN KEY(id_user) REFERENCES utilisateur(id_user)
);
```

### Tables d'association

Ces tables materialisent les relations plusieurs-a-plusieurs du MCD.

```sql
-- Table PARTICIPER : Inscription des unites aux sessions de programme
-- Cle primaire composite (id_unite, id_session)
CREATE TABLE participer(
   id_unite INT,
   id_session INT,
   date_inscription DATE NOT NULL,
   statut VARCHAR(40) NOT NULL,             -- Inscrit, en cours, termine, abandonne
   resultat_obtenu VARCHAR(160),            -- Resultat de la participation
   PRIMARY KEY(id_unite, id_session),
   FOREIGN KEY(id_unite) REFERENCES unite_informelle(id_unite),
   FOREIGN KEY(id_session) REFERENCES session_prog(id_session)
);

-- Table DECLARER_DIFFICULTE : Difficultes rencontrees par les unites
CREATE TABLE DECLARER_DIFFICULTE_(
   id_unite INT,
   id_diff INT,
   PRIMARY KEY(id_unite, id_diff),
   FOREIGN KEY(id_unite) REFERENCES unite_informelle(id_unite),
   FOREIGN KEY(id_diff) REFERENCES difficulte(id_diff)
);

-- Table DECLARER_RISQUE : Risques identifies pour les unites
CREATE TABLE DECLARER_RISQUE_(
   id_unite INT,
   id_risque INT,
   PRIMARY KEY(id_unite, id_risque),
   FOREIGN KEY(id_unite) REFERENCES unite_informelle(id_unite),
   FOREIGN KEY(id_risque) REFERENCES risque(id_risque)
);

-- Table EXPRIMER_BESOIN : Besoins exprimes par les unites
CREATE TABLE EXPRIMER_BESOIN_(
   id_unite INT,
   id_besoin INT,
   PRIMARY KEY(id_unite, id_besoin),
   FOREIGN KEY(id_unite) REFERENCES unite_informelle(id_unite),
   FOREIGN KEY(id_besoin) REFERENCES besoin(id_besoin)
);
```

## Commentaires sur l'implementation

### Integrite referentielle

Toutes les cles etrangeres garantissent la coherence des donnees :

- **CASCADE implicite** : Les suppressions doivent etre gerees manuellement pour eviter les orphelins
- **Contraintes UNIQUE composites** : Assurent l'unicite metier (ex: nom_dept + id_region)

### Valeurs par defaut

- `date_creation` : Initialise automatiquement avec NOW() lors de la creation d'un utilisateur
- `actif` : TRUE par defaut pour les nouveaux comptes
- `couverture_sociale` : FALSE par defaut (majorite des travailleurs informels)

### Points d'attention

1. **Table unite_informelle** : La contrainte UNIQUE(id_site) impose qu'un site ne peut heberger qu'une seule unite
2. **Tables de vulnerabilites** : Structure simple (id, libelle) facilitant l'ajout de nouvelles categories
3. **Table situation_eco** : L'unicite (id_unite, date_obs) permet l'historisation temporelle

# Dictionnaire des donnees {#dictionnaire}

## Tables principales

### Table ROLE {#dict-role}

```{r dict-role}
role <- data.frame(
  Champ = c("id_role", "libelle_role"),
  Type = c("SERIAL", "VARCHAR(50)"),
  Contraintes = c("PK", "UNIQUE, NOT NULL"),
  Description = c("Identifiant unique du role", "Libelle du role")
)
role <- escape_underscore(role)
knitr::kable(role, caption = "Structure de la table ROLE", escape = TRUE)
```

### Table UTILISATEUR {#dict-user}

```{r dict-user}
user <- data.frame(
  Champ = c("id_user", "nom", "prenom", "email", "telephone", "date_creation", "actif", "id_role"),
  Type = c("SERIAL", "VARCHAR(80)", "VARCHAR(80)", "VARCHAR(120)", "VARCHAR(30)", "TIMESTAMP", "BOOLEAN", "INT"),
  Contraintes = c("PK", "NOT NULL", "NOT NULL", "UNIQUE, NOT NULL", "-", "NOT NULL, DEFAULT NOW()", "NOT NULL, DEFAULT TRUE", "FK vers role"),
  Description = c("Identifiant unique", "Nom de l utilisateur", "Prenom de l utilisateur", "Adresse email", "Numero de telephone", "Date de creation du compte", "Statut du compte", "Role de l utilisateur")
)
user <- escape_underscore(user)
knitr::kable(user, caption = "Structure de la table UTILISATEUR", escape = TRUE)
```

### Table UNITE_INFORMELLE {#dict-unite}

```{r dict-unite}
unite <- data.frame(
  Champ = c("id_unite", "code_unite", "nom_activite", "type_activite", "statut_juridique", 
            "date_creation", "niveau_formalisation", "ca_estime", "id_site", "id_activite"),
  Type = c("SERIAL", "VARCHAR(40)", "VARCHAR(160)", "VARCHAR(80)", "VARCHAR(60)",
           "DATE", "VARCHAR(40)", "NUMERIC(18,2)", "INT", "INT"),
  Contraintes = c("PK", "UNIQUE, NOT NULL", "NOT NULL", "-", "-",
                  "-", "NOT NULL", ">= 0", "FK vers site, NOT NULL", "FK vers activite_eco, NOT NULL"),
  Description = c("Identifiant unique", "Code d identification", "Nom de l activite principale", 
                  "Type d activite", "Statut juridique", "Date de creation de l unite",
                  "Niveau de formalisation", "Chiffre d affaires estime", "Site de localisation", "Activite economique")
)
unite <- escape_underscore(unite)
knitr::kable(unite, caption = "Structure de la table UNITE_INFORMELLE", escape = TRUE)
```

### Table TRAVAILLEUR {#dict-trav}

```{r dict-trav}
trav <- data.frame(
  Champ = c("id_trav", "identifiant_ext", "sexe", "age", "niveau_instruction", 
            "role_unite", "anciennete_mois", "couverture_sociale", "id_unite"),
  Type = c("SERIAL", "VARCHAR(60)", "CHAR(1)", "INT", "VARCHAR(60)",
           "VARCHAR(40)", "INT", "BOOLEAN", "INT"),
  Contraintes = c("PK", "-", "NOT NULL, IN (M,F)", "BETWEEN 10 AND 100", "-",
                  "NOT NULL", ">= 0", "NOT NULL, DEFAULT FALSE", "FK vers unite_informelle"),
  Description = c("Identifiant unique", "Identifiant externe", "Sexe du travailleur", 
                  "Age", "Niveau d instruction", "Role dans l unite",
                  "Anciennete en mois", "Protection sociale", "Unite d appartenance")
)
trav <- escape_underscore(trav)
knitr::kable(trav, caption = "Structure de la table TRAVAILLEUR", escape = TRUE)
```

### Table SITUATION_ECO {#dict-sit}

```{r dict-sit}
sit <- data.frame(
  Champ = c("id_sit", "nb_travailleurs_decl", "revenu_mensuel_estime", "charges_principales", 
            "variation_saisonniere", "date_obs", "id_unite"),
  Type = c("SERIAL", "INT", "NUMERIC(18,2)", "NUMERIC(18,2)", "VARCHAR(60)", "DATE", "INT"),
  Contraintes = c("PK", ">= 0", ">= 0", ">= 0", "-", "NOT NULL", "FK vers unite_informelle"),
  Description = c("Identifiant unique", "Nombre de travailleurs declares", "Revenu mensuel estime",
                  "Charges principales", "Type de variation saisonniere", "Date d observation", "Unite concernee")
)
sit <- escape_underscore(sit)
knitr::kable(sit, caption = "Structure de la table SITUATION_ECO", escape = TRUE)
```

## Tables d'association

### Table PARTICIPER {#dict-participer}

```{r dict-participer}
part <- data.frame(
  Champ = c("id_unite", "id_session", "date_inscription", "statut", "resultat_obtenu", "montant_financement"),
  Type = c("INT", "INT", "DATE", "VARCHAR(40)", "VARCHAR(160)", "NUMERIC(18,2)"),
  Contraintes = c("PK, FK vers unite_informelle", "PK, FK vers session_prog", "NOT NULL", "NOT NULL", "-", ">= 0"),
  Description = c("Unite participante", "Session concernee", "Date d inscription", 
                  "Statut de participation", "Resultat obtenu", "Montant du financement")
)
part <- escape_underscore(part)
knitr::kable(part, caption = "Structure de la table PARTICIPER", escape = TRUE)
```

### Table DECLARER_DIFFICULTE {#dict-dd}

```{r dict-dd}
dd <- data.frame(
  Champ = c("id_unite", "id_diff", "date_decl", "niveau_severite"),
  Type = c("INT", "INT", "DATE", "INT"),
  Contraintes = c("PK, FK vers unite_informelle", "PK, FK vers difficulte", "PK, NOT NULL", "BETWEEN 1 AND 5"),
  Description = c("Unite declarante", "Type de difficulte", "Date de declaration", "Niveau de severite")
)
dd <- escape_underscore(dd)
knitr::kable(dd, caption = "Structure de la table DECLARER_DIFFICULTE", escape = TRUE)
```

# Contraintes d'intégrité {#contraintes}

## Contraintes d entite

## Contraintes d'intégrité

Les contraintes d'intégrité sont essentielles pour garantir la cohérence, la fiabilité et la qualité des données dans une base relationnelle. On distingue principalement trois types de contraintes :

### 1. Contraintes d'entité (Clés primaires)
Chaque table possède une clé primaire (généralement de type `SERIAL` ou une clé composite) qui assure l'unicité de chaque enregistrement. Cela signifie qu'aucune ligne ne peut avoir la même valeur de clé primaire qu'une autre, ce qui évite les doublons et permet d'identifier chaque enregistrement de façon unique.

### 2. Contraintes référentielles (Clés étrangères)
Les clés étrangères relient les tables entre elles et assurent la cohérence des liens : une valeur de clé étrangère dans une table doit obligatoirement exister comme clé primaire dans la table cible. Par exemple, la colonne `id_region` dans la table `departement` doit correspondre à une région existante dans la table `region`. Les actions sur suppression (`ON DELETE`) précisent le comportement en cas de suppression d'une donnée référencée : 
- `RESTRICT` empêche la suppression si des données dépendent de la valeur,
- `CASCADE` supprime automatiquement les données liées.

Le tableau ci-dessous synthétise les principales contraintes référentielles du schéma :

```{r ref}
ref <- data.frame(
  Source = c("utilisateur", "departement", "commune", "site", "unite_informelle",
                     "travailleur", "situation_eco", "utiliser", "declarer_difficulte",
                     "session_prog", "participer", "document"),
  FK = c("id_role", "id_region", "id_dept", "id_commune", "id_site, id_activite",
                      "id_unite", "id_unite", "id_activite, id_equipement", "id_unite, id_diff",
                      "id_prog", "id_unite, id_session", "id_user, id_unite"),
  Cible = c("role", "region", "departement", "commune", "site, activite_eco",
                    "unite_informelle", "unite_informelle", "activite_eco, equipement", "unite_informelle, difficulte",
                    "programme", "unite_informelle, session_prog", "utilisateur, unite_informelle"),
  OnDelete = c("RESTRICT", "RESTRICT", "RESTRICT", "RESTRICT", "RESTRICT",
                  "RESTRICT", "RESTRICT", "CASCADE", "CASCADE", "CASCADE", "CASCADE", "RESTRICT/CASCADE")
)
ref <- escape_underscore(ref)
knitr::kable(ref, caption = "Contraintes référentielles",
             col.names = c("Table source", "Clé étrangère", "Table cible", "ON DELETE"), escape = TRUE)
```

### 3. Contraintes de domaine
Les contraintes de domaine imposent des règles sur les valeurs autorisées dans une colonne : elles limitent les valeurs possibles pour garantir la validité métier. Par exemple, le sexe d’un travailleur doit être "M" ou "F", l'âge doit être compris entre 10 et 100, ou encore le chiffre d’affaires estimé doit être positif. Ces contraintes sont souvent définies par des expressions ou des intervalles.

```{r domaine}
dom <- data.frame(
  Table = c("travailleur", "travailleur", "travailleur", "unite_informelle", "situation_eco",
            "programme", "declarer_difficulte", "declarer_risque", "exprimer_besoin"),
  Contrainte = c("ck_trav_sexe", "ck_trav_age", "ck_trav_anciennete", "ck_unite_ca", "ck_sit_*",
                 "ck_prog_dates", "ck_dd_niveau", "ck_dr_prob", "ck_eb_priorite"),
  Expression = c("sexe IN (M,F)", "age BETWEEN 10 AND 100", "anciennete_mois >= 0",
                 "ca_estime >= 0", "valeurs >= 0", "date_fin >= date_debut",
                 "niveau_severite BETWEEN 1 AND 5", "probabilite_percue BETWEEN 1 AND 5", "priorite BETWEEN 1 AND 5")
)
dom <- escape_underscore(dom)
knitr::kable(dom, caption = "Contraintes de domaine", escape = TRUE)
```

### 4. Contraintes d’unicité
Les contraintes d’unicité garantissent qu’une valeur (ou une combinaison de valeurs) n’apparaît qu’une seule fois dans une table. Cela évite les doublons sur des colonnes qui doivent être uniques, comme les adresses email des utilisateurs, les codes d’unité, ou les noms de région. Les contraintes d’unicité peuvent porter sur une seule colonne ou sur plusieurs colonnes combinées.

```{r unicite}
unic <- data.frame(
  Table = c("role", "utilisateur", "region", "departement", "commune", "site",
            "unite_informelle", "situation_eco", "equipement", "difficulte", "risque", "besoin"),
  Contrainte = c("uq_role_libelle", "uq_utilisateur_email", "uq_region_nom", "uq_departement_nom_region",
                 "uq_commune_nom_dept", "uq_site_nom_commune", "uq_unite_code", "uq_sit_unite_date",
                 "uq_equipement_libelle", "uq_difficulte_libelle", "uq_risque_libelle", "uq_besoin_libelle"),
  Colonnes = c("libelle_role", "email", "nom_region", "(nom_dept, id_region)",
               "(nom_commune, id_dept)", "(nom_site, id_commune)", "code_unite", "(id_unite, date_obs)",
               "libelle_equipement", "libelle_diff", "libelle_risque", "libelle_besoin")
)
unic <- escape_underscore(unic)
knitr::kable(unic, caption = "Contraintes d’unicité", escape = TRUE)
```

En résumé, la combinaison de ces contraintes permet de structurer la base de données de façon robuste, d’éviter les incohérences et de garantir la qualité des informations stockées.

# Scénarios utilisateurs {#usecases}

Cette section illustre deux cas d'utilisation caractéristiques qui démontrent la valeur ajoutée d'une base de données structurée pour la gestion du secteur informel au Sénégal.

## UC1 : Recensement territorial d'une unité informelle

**Acteur** : Agent de recensement  
**Contexte** : Terrain à Touba, département de Mbacké, région de Diourbel

**Problématique sans base de données** : L'agent collecte des informations sur papier (nom de l'unité, localisation approximative, type d'activité). Les données restent isolées, impossibles à croiser avec d'autres sources. Aucune vérification de doublons n'est possible. La consolidation nationale prend plusieurs mois.

**Solution avec la base de données** :

1. **Saisie géolocalisée** : L'agent enregistre l'unité "Atelier Serigne Fallou" avec ses coordonnées GPS précises, rattachée automatiquement au site "Marché Ocass" → commune de Touba → département de Mbacké → région de Diourbel.

2. **Vérification instantanée** : Le système détecte qu'une unité similaire existe déjà à 50 mètres (détection de doublon potentiel basée sur le nom et la proximité géographique).

3. **Enrichissement structuré** : L'agent sélectionne l'activité "Menuiserie métallique" dans le référentiel normalisé, enregistre les équipements (1 poste à souder, 2 établis) depuis la nomenclature prédéfinie.

4. **Impact** : Les données sont immédiatement disponibles pour les analyses régionales. Le superviseur peut visualiser en temps réel la progression du recensement. Les statistiques nationales intègrent automatiquement cette nouvelle unité.

**Requête SQL illustrative** :
```sql
-- Insertion d'une nouvelle unité avec ses relations territoriales
INSERT INTO Unite_Informelle (
    nom_unite, date_creation, 
    statut_juridique, id_site, id_activite
)
VALUES (
    'Atelier Serigne Fallou', 
    '2024-03-15',
    'Non enregistrée', 
    (SELECT id_site FROM Site WHERE nom_site = 'Marché Ocass'),
    (SELECT id_activite FROM Activite WHERE libelle = 'Menuiserie métallique')
);

-- Vérification automatique des doublons potentiels dans un rayon de 100m
SELECT u.nom_unite, u.date_creation, s.nom_site,
       ST_Distance(s1.geom, s2.geom) AS distance_metres
FROM Unite_Informelle u
JOIN Site s ON u.id_site = s.id_site
JOIN Site s1 ON s1.nom_site = 'Marché Ocass'
JOIN Site s2 ON u.id_site = s2.id_site
WHERE u.nom_unite ILIKE '%Serigne Fallou%'
  AND ST_DWithin(s1.geom, s2.geom, 100)
  AND u.id_unite != (SELECT MAX(id_unite) FROM Unite_Informelle);
```

**Bénéfices mesurables** :

- Réduction du temps de consolidation : de 3 mois à quelques secondes
- Taux d'erreur de localisation : de 40% (adresses approximatives) à <5% (GPS)
- Élimination des doublons : détection automatique vs. détection manuelle post-collecte

---

## UC2 : Analyse stratégique pour une politique publique ciblée

**Acteur** : Analyste à l'ANSD (Agence Nationale de la Statistique et de la Démographie)  
**Contexte** : Préparation d'un programme de formalisation dans la région de Dakar

**Problématique sans base de données** : Les données sont éparpillées dans des fichiers Excel isolés, collectés par différents services à différentes dates. Impossible de croiser les vulnérabilités économiques avec les besoins en formation. Les analyses prennent des semaines et sont souvent obsolètes à la publication.

**Solution avec la base de données** :

L'analyste doit identifier les unités prioritaires pour un programme pilote de formalisation combinant micro-crédit et formation professionnelle.

**Critères d'éligibilité** :
- Unités actives depuis plus de 2 ans (stabilité)
- Chiffre d'affaires mensuel entre 200 000 et 500 000 FCFA (viabilité)
- Au moins une difficulté économique déclarée de niveau "Élevé"
- Besoin exprimé en formation ou financement
- Localisation dans le département de Dakar

**Requête SQL unique** :
```sql
WITH unites_eligibles AS (
    SELECT 
        u.id_unite,
        u.nom_unite,
        c.nom_commune,
        d.nom_departement,
        a.libelle AS activite,
        -- Ancienneté
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, u.date_creation)) AS anciennete_annees,
        -- CA mensuel moyen sur 6 derniers mois
        AVG(o.chiffre_affaires_mensuel) AS ca_moyen,
        -- Nombre de difficultés élevées
        COUNT(DISTINCT diff.id_difficulte) AS nb_difficultes_elevees,
        -- Besoins exprimés
        STRING_AGG(DISTINCT b.libelle, ', ') AS besoins_exprimes
    FROM Unite_Informelle u
    JOIN Site s ON u.id_site = s.id_site
    JOIN Commune c ON s.id_commune = c.id_commune
    JOIN Departement d ON c.id_departement = d.id_departement
    JOIN Activite a ON u.id_activite = a.id_activite
    LEFT JOIN Observation_Economique o ON u.id_unite = o.id_unite
        AND o.date_observation >= CURRENT_DATE - INTERVAL '6 months'
    LEFT JOIN Exprimer expr ON u.id_unite = expr.id_unite
    LEFT JOIN Difficulte diff ON expr.id_difficulte = diff.id_difficulte
        AND expr.niveau_severite = 'Élevé'
    LEFT JOIN Exprimer_Besoin eb ON u.id_unite = eb.id_unite
    LEFT JOIN Besoin b ON eb.id_besoin = b.id_besoin
        AND b.categorie IN ('Formation', 'Financement')
    WHERE 
        u.statut_activite = 'Active'
        AND d.nom_departement = 'Dakar'
    GROUP BY u.id_unite, u.nom_unite, c.nom_commune, d.nom_departement, 
             a.libelle, u.date_creation
)
SELECT 
    nom_unite,
    nom_commune,
    activite,
    anciennete_annees,
    ROUND(ca_moyen) AS ca_mensuel_moyen_fcfa,
    nb_difficultes_elevees,
    besoins_exprimes
FROM unites_eligibles
WHERE anciennete_annees >= 2
  AND ca_moyen BETWEEN 200000 AND 500000
  AND nb_difficultes_elevees >= 1
  AND besoins_exprimes IS NOT NULL
ORDER BY nb_difficultes_elevees DESC, ca_moyen DESC
LIMIT 50;
```

**Résultat obtenu en 2 secondes** :

| nom_unite | nom_commune | activite | ancienneté | CA moyen | difficultés | besoins |
|-----------|-------------|----------|------------|----------|-------------|---------|
| Couture Mariama | Médina | Confection textile | 4 ans | 380 000 | 3 | Formation, Financement |
| Atelier Mbaye | Plateau | Menuiserie bois | 3 ans | 425 000 | 2 | Formation |
| ... | ... | ... | ... | ... | ... | ... |

**Impact décisionnel** :

- **Ciblage précis** : 50 unités identifiées en 2 secondes vs. plusieurs semaines de tri manuel
- **Priorisation objective** : Critères multiples combinés automatiquement (vulnérabilité × viabilité × besoins)
- **Traçabilité** : Méthodologie de sélection documentée et reproductible
- **Réactivité** : Possibilité d'ajuster les critères et relancer l'analyse immédiatement
- **Équité territoriale** : Analyse réplicable pour toutes les régions avec les mêmes critères

**Bénéfices stratégiques** :

- **Efficacité budgétaire** : Concentration des ressources sur les unités à fort potentiel de formalisation
- **Lutte contre les inégalités** : Identification objective des zones sous-desservies
- **Suivi longitudinal** : Capacité à évaluer l'impact du programme 6 mois après via les mêmes indicateurs
- **Aide à la décision éclairée** : Les décideurs disposent de données actualisées et fiables

---

## Synthèse de la valeur ajoutée

Ces deux scénarios illustrent comment la base de données transforme la gestion du secteur informel :

1. **Au niveau opérationnel (UC1)** : Passage d'une collecte papier désorganisée à un système intégré garantissant qualité, traçabilité et consolidation instantanée.

2. **Au niveau stratégique (UC2)** : Passage d'analyses laborieuses et obsolètes à des diagnostics multidimensionnels en temps réel, permettant des politiques publiques ciblées et évaluables.

La base de données ne se contente pas de stocker l'information : elle la structure, la sécurise, la croise et la valorise pour éclairer la décision publique au service du développement du secteur informel sénégalais.

# Propositions d extension {#extensions}

## Ameliorations fonctionnelles

1. **Geolocalisation** : Ajouter des coordonnees GPS (latitude, longitude) a la table SITE pour la cartographie

2. **Historisation du niveau de formalisation** : Creer une table HISTORIQUE_FORMALISATION pour suivre l evolution

3. **Anonymisation et vues statistiques** : Creer des vues agregees sans donnees nominatives pour les decideurs

4. **Detection de doublons** : Mettre en place des contraintes et triggers pour identifier les unites potentiellement dupliquees

5. **Indice synthetique de vulnerabilite** : Calculer un score composite base sur difficultes, risques et besoins

## Ameliorations techniques

1. **Partitionnement** : Partitionner SITUATION_ECO par annee pour ameliorer les performances

2. **Audit trail** : Ajouter des colonnes created_at, updated_at, created_by, updated_by

3. **Soft delete** : Implementer la suppression logique plutot que physique

4. **Full-text search** : Activer la recherche plein texte sur les descriptions


# Requetes SQL {#requetes}

## Requetes simples

### R1 : Liste des regions

```sql
SELECT id_region, nom_region 
FROM region 
ORDER BY nom_region;
```

### R2 : Nombre d unites par site

```sql
SELECT s.nom_site, COUNT(u.id_unite) AS nb_unites
FROM site s
LEFT JOIN unite_informelle u ON s.id_site = u.id_site
GROUP BY s.id_site, s.nom_site
ORDER BY nb_unites DESC;
```

### R3 : Travailleurs sans couverture sociale

```sql
SELECT t.id_trav, t.sexe, t.age, t.role_unite
FROM travailleur t
WHERE t.couverture_sociale = FALSE;
```

## Requetes intermediaires

### R4 : Revenu moyen par secteur d activite

```sql
SELECT a.secteur, 
       AVG(se.revenu_mensuel_estime) AS revenu_moyen,
       COUNT(DISTINCT u.id_unite) AS nb_unites
FROM activite_eco a
JOIN unite_informelle u ON a.id_activite = u.id_activite
JOIN situation_eco se ON u.id_unite = se.id_unite
GROUP BY a.secteur
ORDER BY revenu_moyen DESC;
```

### R5 : Unites ayant declare plus de 3 difficultes

```sql
SELECT u.code_unite, u.nom_activite, COUNT(dd.id_diff) AS nb_difficultes
FROM unite_informelle u
JOIN declarer_difficulte dd ON u.id_unite = dd.id_unite
GROUP BY u.id_unite, u.code_unite, u.nom_activite
HAVING COUNT(dd.id_diff) > 3
ORDER BY nb_difficultes DESC;
```

### R6 : Taux de couverture sociale par region

```sql
SELECT r.nom_region,
       COUNT(t.id_trav) AS nb_travailleurs,
       SUM(CASE WHEN t.couverture_sociale THEN 1 ELSE 0 END) AS avec_couverture,
       ROUND(100.0 * SUM(CASE WHEN t.couverture_sociale THEN 1 ELSE 0 END) 
             / COUNT(t.id_trav), 2) AS taux_couverture
FROM region r
JOIN departement d ON r.id_region = d.id_region
JOIN commune c ON d.id_dept = c.id_dept
JOIN site s ON c.id_commune = s.id_commune
JOIN unite_informelle u ON s.id_site = u.id_site
JOIN travailleur t ON u.id_unite = t.id_unite
GROUP BY r.id_region, r.nom_region
ORDER BY taux_couverture DESC;
```

## Requetes avancees

### R7 : Evolution du revenu moyen par trimestre

```sql
SELECT 
    EXTRACT(YEAR FROM se.date_obs) AS annee,
    EXTRACT(QUARTER FROM se.date_obs) AS trimestre,
    AVG(se.revenu_mensuel_estime) AS revenu_moyen,
    COUNT(DISTINCT se.id_unite) AS nb_observations
FROM situation_eco se
GROUP BY EXTRACT(YEAR FROM se.date_obs), EXTRACT(QUARTER FROM se.date_obs)
ORDER BY annee, trimestre;
```

### R8 : Top 10 des programmes avec le plus de participants

```sql
SELECT p.nom_prog, p.type_prog, p.organisme,
       COUNT(DISTINCT par.id_unite) AS nb_participants,
       SUM(par.montant_financement) AS total_financement
FROM programme p
JOIN session_prog sp ON p.id_prog = sp.id_prog
JOIN participer par ON sp.id_session = par.id_session
GROUP BY p.id_prog, p.nom_prog, p.type_prog, p.organisme
ORDER BY nb_participants DESC
LIMIT 10;
```

### R9 : Indice de vulnerabilite par unite

```sql
WITH scores AS (
    SELECT u.id_unite, u.code_unite, u.nom_activite,
           COALESCE(AVG(dd.niveau_severite), 0) AS score_difficulte,
           COALESCE(AVG(dr.probabilite_percue), 0) AS score_risque,
           COALESCE(AVG(eb.priorite), 0) AS score_besoin
    FROM unite_informelle u
    LEFT JOIN declarer_difficulte dd ON u.id_unite = dd.id_unite
    LEFT JOIN declarer_risque dr ON u.id_unite = dr.id_unite
    LEFT JOIN exprimer_besoin eb ON u.id_unite = eb.id_unite
    GROUP BY u.id_unite, u.code_unite, u.nom_activite
)
SELECT code_unite, nom_activite,
       ROUND(score_difficulte, 2) AS score_difficulte,
       ROUND(score_risque, 2) AS score_risque,
       ROUND(score_besoin, 2) AS score_besoin,
       ROUND((score_difficulte + score_risque + score_besoin) / 3, 2) 
         AS indice_vulnerabilite
FROM scores
WHERE (score_difficulte + score_risque + score_besoin) > 0
ORDER BY indice_vulnerabilite DESC;
```

### R10 : Tableau croise activites x difficultes

```sql
SELECT a.secteur, d.libelle_diff, COUNT(*) AS nb_declarations
FROM activite_eco a
JOIN unite_informelle u ON a.id_activite = u.id_activite
JOIN declarer_difficulte dd ON u.id_unite = dd.id_unite
JOIN difficulte d ON dd.id_diff = d.id_diff
GROUP BY a.secteur, d.libelle_diff
ORDER BY a.secteur, nb_declarations DESC;
```

# Conclusion {-}

Ce projet a permis de concevoir une base de donnees relationnelle complete pour la gestion du secteur informel au Senegal. La methodologie Merise a guide la modelisation depuis l analyse des besoins jusqu a l implementation PostgreSQL.

Les points cles de cette conception sont :

1. **Couverture fonctionnelle complete** : referentiels, unites, travailleurs, suivi economique, vulnerabilites, programmes d appui et documents

2. **Integrite des donnees** : contraintes referentielles, de domaine et d unicite rigoureuses

3. **Historisation** : observations economiques et declarations de vulnerabilites datees

4. **Extensibilite** : structure modulaire permettant des evolutions futures

5. **Performance** : index optimises pour les requetes frequentes

Cette base de donnees constitue un socle solide pour la production d indicateurs fiables et l aide a la decision en matiere de politiques publiques d accompagnement du secteur informel.

# (APPENDIX) Annexes {-}

# Schema MCD Merise {#annexe-mcd}

Le diagramme MCD complet est fourni dans le fichier `Projet_looping.loo`.

# Script SQL complet {#annexe-sql}

Le script DDL PostgreSQL complet est fourni dans le fichier `MPD.sql`.

# Résumé du projet {-}
> Ce rapport présente la conception et l’implémentation d’une base de données relationnelle dédiée au suivi du secteur informel au Sénégal. Il s’appuie sur la méthodologie Merise et propose une modélisation complète, des schémas visuels, des dictionnaires de données et des requêtes SQL adaptées.

# Méthodologie {-}
La démarche suit les étapes classiques de la méthode Merise :
- Analyse fonctionnelle
- Modélisation conceptuelle (MCD)
- Modélisation logique (MLD)
- Modélisation physique (MPD)
- Génération des scripts SQL et documentation


# Limites et perspectives {-}
- Automatisation possible de la génération des scripts SQL à partir du MCD.
- Ajout d’une API pour l’interrogation dynamique de la base.
- Extension possible vers la gestion des données géographiques (SIG).

# Glossaire {-}
- **MCD** : Modèle Conceptuel de Données
- **MLD** : Modèle Logique de Données
- **MPD** : Modèle Physique de Données
- **SGBDR** : Système de Gestion de Base de Données Relationnelle

# Références {-}
- [Méthode Merise](https://fr.wikipedia.org/wiki/Merise)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Bookdown Documentation](https://bookdown.org/yihui/bookdown/)
